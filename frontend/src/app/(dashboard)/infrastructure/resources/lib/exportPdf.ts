import type { KpiData, PredictiveAlert, OverprovisioningData, GreenMetrics, NetworkMetrics, TopVm } from '../types'
import type { HealthScoreBreakdown } from '../algorithms/healthScore'
import { formatPct, formatBytes, formatBytesPerSec } from '../helpers'
import { COLORS } from '../constants'

type ExportData = {
  kpis: KpiData
  healthScore: number
  healthBreakdown: HealthScoreBreakdown
  alerts: PredictiveAlert[]
  overprovisioning: OverprovisioningData | null
  green: GreenMetrics | null
  networkMetrics: NetworkMetrics | null
  topCpuVms: TopVm[]
  topRamVms: TopVm[]
}

// ---------- Colors ----------
const PRIMARY = '#6366f1'
const TEXT_DARK = '#1e293b'
const TEXT_MED = '#475569'
const TEXT_LIGHT = '#94a3b8'
const BG_LIGHT = '#f8fafc'
const LINE = '#e2e8f0'

function severityColor(sev: string): [number, number, number] {
  switch (sev) {
    case 'critical': case 'high': return [254, 226, 226]   // red-100
    case 'warning': case 'medium': return [254, 243, 199]  // amber-100
    case 'ok': case 'low': case 'info': return [220, 252, 231] // green-100
    default: return [241, 245, 249]
  }
}

function severityTextColor(sev: string): [number, number, number] {
  switch (sev) {
    case 'critical': case 'high': return [185, 28, 28]
    case 'warning': case 'medium': return [146, 64, 14]
    case 'ok': case 'low': case 'info': return [21, 128, 61]
    default: return [71, 85, 105]
  }
}

function healthLabel(score: number): string {
  if (score >= 85) return 'Excellent'
  if (score >= 70) return 'Good'
  if (score >= 50) return 'Needs attention'
  return 'Critical'
}

function hexToRgb(hex: string): [number, number, number] {
  const v = parseInt(hex.replace('#', ''), 16)
  return [(v >> 16) & 255, (v >> 8) & 255, v & 255]
}

function fmtNum(n: number, dec = 1): string {
  return n.toFixed(dec)
}

// ---------- Main export ----------
export async function exportResourcesPdf(data: ExportData): Promise<void> {
  const { jsPDF } = await import('jspdf')
  const { default: autoTableFn } = await import('jspdf-autotable')

  const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' })
  const pageW = doc.internal.pageSize.getWidth()
  const pageH = doc.internal.pageSize.getHeight()
  const margin = 15
  const contentW = pageW - margin * 2
  const now = new Date()
  const dateStr = now.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })
  const dateShort = now.toISOString().slice(0, 10)
  let totalPages = 0

  // Helper: draw header on top of current page
  function addHeader(title: string) {
    doc.setFillColor(PRIMARY)
    doc.rect(0, 0, pageW, 28, 'F')
    doc.setFont('helvetica', 'bold')
    doc.setFontSize(18)
    doc.setTextColor(255, 255, 255)
    doc.text('ProxCenter', margin, 12)
    doc.setFontSize(10)
    doc.setFont('helvetica', 'normal')
    doc.text(title, margin, 20)
    doc.text(dateStr, pageW - margin, 20, { align: 'right' })
  }

  // Helper: draw footer
  function addFooter(page: number) {
    const y = pageH - 8
    doc.setDrawColor(LINE)
    doc.setLineWidth(0.3)
    doc.line(margin, y - 3, pageW - margin, y - 3)
    doc.setFontSize(7)
    doc.setTextColor(TEXT_LIGHT)
    doc.setFont('helvetica', 'normal')
    doc.text(`Generated by ProxCenter — ${dateStr}`, margin, y)
    doc.text(`Page ${page} / ${totalPages}`, pageW - margin, y, { align: 'right' })
  }

  // Helper: section title
  function addSectionTitle(title: string, y: number): number {
    doc.setFont('helvetica', 'bold')
    doc.setFontSize(12)
    doc.setTextColor(...hexToRgb(PRIMARY))
    doc.text(title, margin, y)
    doc.setDrawColor(...hexToRgb(PRIMARY))
    doc.setLineWidth(0.5)
    doc.line(margin, y + 1.5, margin + doc.getTextWidth(title), y + 1.5)
    return y + 8
  }

  // Helper: key-value rows
  function addKvTable(rows: [string, string][], startY: number): number {
    let y = startY
    doc.setFontSize(9)
    const colW = contentW / 2
    for (let i = 0; i < rows.length; i++) {
      if (i % 2 === 0) {
        doc.setFillColor(BG_LIGHT)
        doc.rect(margin, y - 3.5, contentW, 5.5, 'F')
      }
      doc.setFont('helvetica', 'normal')
      doc.setTextColor(TEXT_MED)
      doc.text(rows[i][0], margin + 2, y)
      doc.setFont('helvetica', 'bold')
      doc.setTextColor(TEXT_DARK)
      doc.text(rows[i][1], margin + colW, y)
      y += 5.5
    }
    return y + 2
  }

  // Helper: autoTable wrapper using standalone function (jspdf-autotable v5)
  function autoTable(options: Record<string, unknown>): number {
    autoTableFn(doc as any, {
      startY: options.startY,
      margin: { left: margin, right: margin },
      styles: { fontSize: 8, cellPadding: 2, lineColor: [226, 232, 240], lineWidth: 0.2 },
      headStyles: { fillColor: hexToRgb(PRIMARY), textColor: [255, 255, 255], fontStyle: 'bold', fontSize: 8 },
      alternateRowStyles: { fillColor: [248, 250, 252] },
      ...options,
    } as any)
    return (doc as any).lastAutoTable.finalY + 4
  }

  // ========== PAGE 1 : Cover + KPIs + Health Score ==========
  addHeader('Infrastructure Capacity Report')
  let y = 36

  // -- Health Score --
  y = addSectionTitle('Health Score', y)
  const { kpis, healthScore, healthBreakdown } = data
  const label = healthLabel(healthScore)
  const scoreColor = healthScore >= 85 ? COLORS.success : healthScore >= 70 ? COLORS.info : healthScore >= 50 ? COLORS.warning : COLORS.error

  doc.setFontSize(28)
  doc.setFont('helvetica', 'bold')
  doc.setTextColor(...hexToRgb(scoreColor))
  doc.text(`${healthScore}`, margin + 2, y + 10)
  doc.setFontSize(14)
  doc.text(`/ 100`, margin + 22, y + 10)
  doc.setFontSize(11)
  doc.setTextColor(TEXT_MED)
  doc.text(label, margin + 42, y + 10)
  y += 18

  // Breakdown table
  const breakdownRows = Object.entries(healthBreakdown).map(([key, val]) => {
    const sign = val.penalty > 0 ? '+' : ''
    return [key.toUpperCase(), `${sign}${val.penalty} pts`, val.reason]
  })
  y = autoTable({
    startY: y,
    head: [['Category', 'Impact', 'Detail']],
    body: breakdownRows,
    columnStyles: {
      0: { cellWidth: 30, fontStyle: 'bold' },
      1: { cellWidth: 25, halign: 'center' },
    },
    didParseCell: (d: any) => {
      if (d.section === 'body' && d.column.index === 1) {
        const val = parseInt(d.cell.raw as string)
        if (val < 0) d.cell.styles.textColor = hexToRgb(COLORS.error)
        else if (val > 0) d.cell.styles.textColor = hexToRgb(COLORS.success)
      }
    },
  })

  // -- KPIs --
  y = addSectionTitle('Key Performance Indicators', y)
  const storagePct = kpis.storage.total > 0 ? (kpis.storage.used / kpis.storage.total) * 100 : 0
  const kpiRows: [string, string][] = [
    ['CPU Used', formatPct(kpis.cpu.used)],
    ['CPU Allocated', `${kpis.cpu.allocated} vCPUs`],
    ['CPU Total', `${kpis.cpu.total} cores`],
    ['RAM Used', formatPct(kpis.ram.used)],
    ['RAM Allocated', formatBytes(kpis.ram.allocated)],
    ['RAM Total', formatBytes(kpis.ram.total)],
    ['Storage Used', `${formatBytes(kpis.storage.used)} / ${formatBytes(kpis.storage.total)} (${formatPct(storagePct)})`],
    ['VMs Running', `${kpis.vms.running} / ${kpis.vms.total}`],
    ['VMs Stopped', `${kpis.vms.stopped}`],
    ['Efficiency', formatPct(kpis.efficiency)],
  ]
  y = addKvTable(kpiRows, y)

  // ========== PAGE 2 : Forecasts + Alerts ==========
  doc.addPage()
  addHeader('Capacity Forecasts & Predictive Alerts')
  y = 36

  y = addSectionTitle('Predictive Alerts', y)

  if (data.alerts.length === 0) {
    doc.setFontSize(9)
    doc.setTextColor(TEXT_MED)
    doc.text('No predictive alerts — all resources within safe thresholds.', margin + 2, y)
    y += 8
  } else {
    const alertBody = data.alerts.map(a => [
      a.resource.toUpperCase(),
      formatPct(a.currentValue),
      formatPct(a.predictedValue),
      a.trend,
      a.daysToThreshold !== null ? `${a.daysToThreshold}d` : '—',
      a.severity,
      a.confidence !== undefined ? `${Math.round(a.confidence * 100)}%` : '—',
      a.trendType ?? '—',
    ])
    y = autoTable({
      startY: y,
      head: [['Resource', 'Current', 'Predicted (30d)', 'Trend', 'Days to Threshold', 'Severity', 'Confidence', 'Trend Type']],
      body: alertBody,
      columnStyles: { 0: { fontStyle: 'bold' } },
      didParseCell: (d: any) => {
        if (d.section === 'body' && d.column.index === 5) {
          d.cell.styles.fillColor = severityColor(d.cell.raw as string)
          d.cell.styles.textColor = severityTextColor(d.cell.raw as string)
          d.cell.styles.fontStyle = 'bold'
        }
      },
    })

    // Summary text
    const criticals = data.alerts.filter(a => a.severity === 'critical')
    const warnings = data.alerts.filter(a => a.severity === 'warning')
    y += 2
    doc.setFontSize(9)
    doc.setFont('helvetica', 'bold')
    doc.setTextColor(TEXT_DARK)
    doc.text('Summary:', margin, y)
    doc.setFont('helvetica', 'normal')
    doc.setTextColor(TEXT_MED)
    const parts: string[] = []
    if (criticals.length) parts.push(`${criticals.length} critical alert(s)`)
    if (warnings.length) parts.push(`${warnings.length} warning(s)`)
    if (parts.length === 0) parts.push('No critical or warning alerts')
    doc.text(parts.join(', '), margin + 22, y)
    y += 5
    if (criticals.length > 0) {
      const most = criticals[0]
      doc.text(`Most at risk: ${most.resource.toUpperCase()} — predicted ${formatPct(most.predictedValue)} in 30 days`, margin + 22, y)
    }
  }

  // ========== PAGE 3 : Overprovisioning ==========
  if (data.overprovisioning) {
    doc.addPage()
    addHeader('Overprovisioning Analysis')
    y = 36

    const op = data.overprovisioning

    y = addSectionTitle('Global Overprovisioning', y)
    const opGlobalRows: [string, string][] = [
      ['CPU Ratio (allocated:physical)', `${fmtNum(op.cpu.ratio)}:1`],
      ['CPU Efficiency', formatPct(op.cpu.efficiency)],
      ['RAM Ratio (allocated:physical)', `${fmtNum(op.ram.ratio)}:1`],
      ['RAM Efficiency', formatPct(op.ram.efficiency)],
    ]
    y = addKvTable(opGlobalRows, y)

    // Per-node table
    if (op.perNode.length > 0) {
      y = addSectionTitle('Per-Node Breakdown', y)
      const nodeBody = op.perNode.map(n => [
        n.name,
        `${fmtNum(n.cpuRatio)}:1`,
        `${fmtNum(n.ramRatio)}:1`,
        `${n.cpuAllocated}`,
        `${n.cpuPhysical}`,
        formatBytes(n.ramAllocated),
        formatBytes(n.ramPhysical),
      ])
      y = autoTable({
        startY: y,
        head: [['Node', 'CPU Ratio', 'RAM Ratio', 'CPU Alloc', 'CPU Phys', 'RAM Alloc', 'RAM Phys']],
        body: nodeBody,
        columnStyles: { 0: { fontStyle: 'bold' } },
      })
    }

    // Top overprovisioned VMs
    if (op.topOverprovisioned.length > 0) {
      y = addSectionTitle('Top VMs to Optimize', y)

      // Check if we need a new page
      if (y > pageH - 60) {
        doc.addPage()
        addHeader('Overprovisioning Analysis (cont.)')
        y = 36
      }

      const vmBody = op.topOverprovisioned.map(vm => [
        vm.name,
        vm.node,
        `${vm.cpuAllocated}`,
        formatPct(vm.cpuUsedPct),
        `${vm.recommendedCpu}`,
        `${fmtNum(vm.ramAllocatedGB)} GB`,
        formatPct(vm.ramUsedPct),
        `${fmtNum(vm.recommendedRamGB)} GB`,
        `CPU: ${vm.potentialSavings.cpu}, RAM: ${fmtNum(vm.potentialSavings.ramGB)} GB`,
      ])
      y = autoTable({
        startY: y,
        head: [['VM', 'Node', 'CPU Alloc', 'CPU Used%', 'Reco CPU', 'RAM Alloc', 'RAM Used%', 'Reco RAM', 'Savings']],
        body: vmBody,
        columnStyles: { 0: { fontStyle: 'bold' } },
        styles: { fontSize: 7, cellPadding: 1.5 },
      })
    }
  }

  // ========== PAGE 4 : Green Metrics ==========
  if (data.green) {
    doc.addPage()
    addHeader('Green Metrics / RSE')
    y = 36
    const g = data.green

    y = addSectionTitle('Efficiency', y)
    y = addKvTable([
      ['PUE (Power Usage Effectiveness)', fmtNum(g.efficiency.pue, 2)],
      ['VMs per kW', fmtNum(g.efficiency.vmPerKw, 2)],
      ['Green Score', `${Math.round(g.efficiency.score)} / 100`],
    ], y)

    y = addSectionTitle('Power Consumption', y)
    y = addKvTable([
      ['Current Power', `${Math.round(g.power.current)} W`],
      ['Monthly Consumption', `${fmtNum(g.power.monthly)} kWh`],
      ['Yearly Consumption', `${fmtNum(g.power.yearly)} kWh`],
    ], y)

    y = addSectionTitle('CO2 Emissions', y)
    y = addKvTable([
      ['Monthly CO2', `${fmtNum(g.co2.monthly)} kg`],
      ['Yearly CO2', `${fmtNum(g.co2.yearly)} kg`],
      ['Equivalent (car)', `${Math.round(g.co2.equivalentKmCar)} km`],
      ['Equivalent (trees)', `${fmtNum(g.co2.equivalentTrees, 0)} trees`],
    ], y)

    y = addSectionTitle('Energy Cost', y)
    y = addKvTable([
      ['Monthly Cost', `${fmtNum(g.cost.monthly, 2)} \u20AC`],
      ['Yearly Cost', `${fmtNum(g.cost.yearly, 2)} \u20AC`],
      ['Price per kWh', `${fmtNum(g.cost.pricePerKwh, 4)} \u20AC`],
    ], y)
  }

  // ========== PAGE 5 : Network I/O ==========
  if (data.networkMetrics) {
    doc.addPage()
    addHeader('Network I/O')
    y = 36
    const net = data.networkMetrics

    y = addSectionTitle('Totals', y)
    y = addKvTable([
      ['Total In', formatBytes(net.totalIn)],
      ['Total Out', formatBytes(net.totalOut)],
    ], y)

    if (net.perNode.length > 0) {
      y = addSectionTitle('Per-Node Network', y)
      const nodeBody = net.perNode.map(n => [n.name, formatBytes(n.netin), formatBytes(n.netout)])
      y = autoTable({
        startY: y,
        head: [['Node', 'Net In', 'Net Out']],
        body: nodeBody,
        columnStyles: { 0: { fontStyle: 'bold' } },
      })
    }

    if (net.topVms.length > 0) {
      y = addSectionTitle('Top VMs by Network', y)
      const vmBody = net.topVms.map(v => [v.name, v.node, formatBytes(v.netin), formatBytes(v.netout)])
      y = autoTable({
        startY: y,
        head: [['VM', 'Node', 'Net In', 'Net Out']],
        body: vmBody,
        columnStyles: { 0: { fontStyle: 'bold' } },
      })
    }
  }

  // ========== Finalize: add footers to all pages ==========
  totalPages = doc.getNumberOfPages()
  for (let i = 1; i <= totalPages; i++) {
    doc.setPage(i)
    addFooter(i)
  }

  doc.save(`proxcenter-capacity-report-${dateShort}.pdf`)
}
